diff -urN --no-dereference a/arch/arm/boot/dts/kirkwood-b3.dts b/arch/arm/boot/dts/kirkwood-b3.dts
--- a/arch/arm/boot/dts/kirkwood-b3.dts	2023-02-25 11:25:43.000000000 +0100
+++ b/arch/arm/boot/dts/kirkwood-b3.dts	2023-05-02 09:45:22.674683031 +0200
@@ -121,17 +121,19 @@
 		programming_led {
 			label = "bubba3:green:programming";
 			gpios = <&gpio1 6 GPIO_ACTIVE_HIGH>;
-			default-state = "off";
+			default-state = "on";
 		};
 
 		error_led {
 			label = "bubba3:red:error";
 			gpios = <&gpio1 9 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
 		};
 
 		active_led {
 			label = "bubba3:blue:active";
 			gpios = <&gpio1 10 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
 		};
 	};
 
diff -urN --no-dereference a/arch/arm/kernel/reboot.c b/arch/arm/kernel/reboot.c
--- a/arch/arm/kernel/reboot.c	2023-02-25 11:25:43.000000000 +0100
+++ b/arch/arm/kernel/reboot.c	2023-05-02 09:43:25.985009824 +0200
@@ -102,9 +102,13 @@
  */
 void machine_halt(void)
 {
+#ifdef CONFIG_KIRKWOOD_ALWAYS_RESTART
+	machine_restart(NULL);
+#else
 	local_irq_disable();
 	smp_send_stop();
 	while (1);
+#endif
 }
 
 /*
@@ -115,9 +119,13 @@
  */
 void machine_power_off(void)
 {
+#ifdef CONFIG_KIRKWOOD_ALWAYS_RESTART
+	machine_restart(NULL);
+#else
 	local_irq_disable();
 	smp_send_stop();
 	do_kernel_power_off();
+#endif
 }
 
 /*
diff -urN --no-dereference a/arch/arm/mach-mvebu/Kconfig b/arch/arm/mach-mvebu/Kconfig
--- a/arch/arm/mach-mvebu/Kconfig	2023-02-25 11:25:43.000000000 +0100
+++ b/arch/arm/mach-mvebu/Kconfig	2023-05-02 09:43:25.985009824 +0200
@@ -128,4 +128,11 @@
 	  Say 'Y' here if you want your kernel to support boards based
 	  on the Marvell Kirkwood device tree.
 
+config KIRKWOOD_ALWAYS_RESTART
+	bool "Restart board when powering off kernel"
+	depends on MACH_KIRKWOOD
+	help
+	  Say 'Y' here if you want your kernel to restart
+	  when asked to power off.
+
 endif
diff -urN --no-dereference a/drivers/net/ethernet/marvell/mv643xx_eth.c b/drivers/net/ethernet/marvell/mv643xx_eth.c
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c	2023-02-25 11:25:43.000000000 +0100
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c	2023-05-02 09:43:20.298358508 +0200
@@ -3201,11 +3201,11 @@
 	dev->watchdog_timeo = 2 * HZ;
 	dev->base_addr = 0;
 
-	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO;
+	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM;
 	dev->vlan_features = dev->features;
 
 	dev->features |= NETIF_F_RXCSUM;
-	dev->hw_features = dev->features;
+	dev->hw_features = dev->features | NETIF_F_TSO;
 
 	dev->priv_flags |= IFF_UNICAST_FLT;
 	netif_set_tso_max_segs(dev, MV643XX_MAX_TSO_SEGS);
diff -urN --no-dereference a/scripts/dtc/checks.c b/scripts/dtc/checks.c
--- a/scripts/dtc/checks.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/checks.c	2023-05-02 09:42:59.268414764 +0200
@@ -143,14 +143,6 @@
 		check_nodes_props(c, dti, child);
 }
 
-static bool is_multiple_of(int multiple, int divisor)
-{
-	if (divisor == 0)
-		return multiple == 0;
-	else
-		return (multiple % divisor) == 0;
-}
-
 static bool run_check(struct check *c, struct dt_info *dti)
 {
 	struct node *dt = dti->dt;
@@ -305,20 +297,19 @@
 #define LOWERCASE	"abcdefghijklmnopqrstuvwxyz"
 #define UPPERCASE	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 #define DIGITS		"0123456789"
-#define NODECHARS	LOWERCASE UPPERCASE DIGITS ",._+-@"
-#define PROPCHARS	LOWERCASE UPPERCASE DIGITS ",._+*#?-"
+#define PROPNODECHARS	LOWERCASE UPPERCASE DIGITS ",._+*#?-"
 #define PROPNODECHARSSTRICT	LOWERCASE UPPERCASE DIGITS ",-"
 
 static void check_node_name_chars(struct check *c, struct dt_info *dti,
 				  struct node *node)
 {
-	size_t n = strspn(node->name, c->data);
+	int n = strspn(node->name, c->data);
 
 	if (n < strlen(node->name))
 		FAIL(c, dti, node, "Bad character '%c' in node name",
 		     node->name[n]);
 }
-ERROR(node_name_chars, check_node_name_chars, NODECHARS);
+ERROR(node_name_chars, check_node_name_chars, PROPNODECHARS "@");
 
 static void check_node_name_chars_strict(struct check *c, struct dt_info *dti,
 					 struct node *node)
@@ -339,20 +330,6 @@
 }
 ERROR(node_name_format, check_node_name_format, NULL, &node_name_chars);
 
-static void check_node_name_vs_property_name(struct check *c,
-					     struct dt_info *dti,
-					     struct node *node)
-{
-	if (!node->parent)
-		return;
-
-	if (get_property(node->parent, node->name)) {
-		FAIL(c, dti, node, "node name and property name conflict");
-	}
-}
-WARNING(node_name_vs_property_name, check_node_name_vs_property_name,
-	NULL, &node_name_chars);
-
 static void check_unit_address_vs_reg(struct check *c, struct dt_info *dti,
 				      struct node *node)
 {
@@ -386,14 +363,14 @@
 	struct property *prop;
 
 	for_each_property(node, prop) {
-		size_t n = strspn(prop->name, c->data);
+		int n = strspn(prop->name, c->data);
 
 		if (n < strlen(prop->name))
 			FAIL_PROP(c, dti, node, prop, "Bad character '%c' in property name",
 				  prop->name[n]);
 	}
 }
-ERROR(property_name_chars, check_property_name_chars, PROPCHARS);
+ERROR(property_name_chars, check_property_name_chars, PROPNODECHARS);
 
 static void check_property_name_chars_strict(struct check *c,
 					     struct dt_info *dti,
@@ -403,7 +380,7 @@
 
 	for_each_property(node, prop) {
 		const char *name = prop->name;
-		size_t n = strspn(name, c->data);
+		int n = strspn(name, c->data);
 
 		if (n == strlen(prop->name))
 			continue;
@@ -520,7 +497,7 @@
 
 	phandle = propval_cell(prop);
 
-	if (!phandle_is_valid(phandle)) {
+	if ((phandle == 0) || (phandle == -1)) {
 		FAIL_PROP(c, dti, node, prop, "bad value (0x%x) in %s property",
 		     phandle, prop->name);
 		return 0;
@@ -579,7 +556,7 @@
 	if (!prop)
 		return; /* No name property, that's fine */
 
-	if ((prop->val.len != node->basenamelen + 1U)
+	if ((prop->val.len != node->basenamelen+1)
 	    || (memcmp(prop->val.val, node->name, node->basenamelen) != 0)) {
 		FAIL(c, dti, node, "\"name\" property is incorrect (\"%s\" instead"
 		     " of base node name)", prop->val.val);
@@ -680,6 +657,7 @@
  */
 WARNING_IF_NOT_CELL(address_cells_is_cell, "#address-cells");
 WARNING_IF_NOT_CELL(size_cells_is_cell, "#size-cells");
+WARNING_IF_NOT_CELL(interrupt_cells_is_cell, "#interrupt-cells");
 
 WARNING_IF_NOT_STRING(device_type_is_string, "device_type");
 WARNING_IF_NOT_STRING(model_is_string, "model");
@@ -694,7 +672,8 @@
 	struct property *prop;
 
 	for_each_property(node, prop) {
-		if (!strends(prop->name, "-names"))
+		const char *s = strrchr(prop->name, '-');
+		if (!s || !streq(s, "-names"))
 			continue;
 
 		c->data = prop->name;
@@ -774,7 +753,7 @@
 	size_cells = node_size_cells(node->parent);
 	entrylen = (addr_cells + size_cells) * sizeof(cell_t);
 
-	if (!is_multiple_of(prop->val.len, entrylen))
+	if (!entrylen || (prop->val.len % entrylen) != 0)
 		FAIL_PROP(c, dti, node, prop, "property has invalid length (%d bytes) "
 			  "(#address-cells == %d, #size-cells == %d)",
 			  prop->val.len, addr_cells, size_cells);
@@ -815,7 +794,7 @@
 				  "#size-cells (%d) differs from %s (%d)",
 				  ranges, c_size_cells, node->parent->fullpath,
 				  p_size_cells);
-	} else if (!is_multiple_of(prop->val.len, entrylen)) {
+	} else if ((prop->val.len % entrylen) != 0) {
 		FAIL_PROP(c, dti, node, prop, "\"%s\" property has invalid length (%d bytes) "
 			  "(parent #address-cells == %d, child #address-cells == %d, "
 			  "#size-cells == %d)", ranges, prop->val.len,
@@ -892,7 +871,7 @@
 	} else {
 		cells = (cell_t *)prop->val.val;
 		min_bus = fdt32_to_cpu(cells[0]);
-		max_bus = fdt32_to_cpu(cells[1]);
+		max_bus = fdt32_to_cpu(cells[0]);
 	}
 	if ((bus_num < min_bus) || (bus_num > max_bus))
 		FAIL_PROP(c, dti, node, prop, "PCI bus number %d out of range, expected (%d - %d)",
@@ -1388,9 +1367,9 @@
 				          const struct provider *provider)
 {
 	struct node *root = dti->dt;
-	unsigned int cell, cellsize = 0;
+	int cell, cellsize = 0;
 
-	if (!is_multiple_of(prop->val.len, sizeof(cell_t))) {
+	if (prop->val.len % sizeof(cell_t)) {
 		FAIL_PROP(c, dti, node, prop,
 			  "property size (%d) is invalid, expected multiple of %zu",
 			  prop->val.len, sizeof(cell_t));
@@ -1400,14 +1379,14 @@
 	for (cell = 0; cell < prop->val.len / sizeof(cell_t); cell += cellsize + 1) {
 		struct node *provider_node;
 		struct property *cellprop;
-		cell_t phandle;
+		int phandle;
 
 		phandle = propval_cell_n(prop, cell);
 		/*
 		 * Some bindings use a cell value 0 or -1 to skip over optional
 		 * entries when each index position has a specific definition.
 		 */
-		if (!phandle_is_valid(phandle)) {
+		if (phandle == 0 || phandle == -1) {
 			/* Give up if this is an overlay with external references */
 			if (dti->dtsflags & DTSF_PLUGIN)
 				break;
@@ -1473,8 +1452,7 @@
 }
 #define WARNING_PROPERTY_PHANDLE_CELLS(nm, propname, cells_name, ...) \
 	static struct provider nm##_provider = { (propname), (cells_name), __VA_ARGS__ }; \
-	WARNING_IF_NOT_CELL(nm##_is_cell, cells_name); \
-	WARNING(nm##_property, check_provider_cells_property, &nm##_provider, &nm##_is_cell, &phandle_references);
+	WARNING(nm##_property, check_provider_cells_property, &nm##_provider, &phandle_references);
 
 WARNING_PROPERTY_PHANDLE_CELLS(clocks, "clocks", "#clock-cells");
 WARNING_PROPERTY_PHANDLE_CELLS(cooling_device, "cooling-device", "#cooling-cells");
@@ -1495,17 +1473,24 @@
 
 static bool prop_is_gpio(struct property *prop)
 {
+	char *str;
+
 	/*
 	 * *-gpios and *-gpio can appear in property names,
 	 * so skip over any false matches (only one known ATM)
 	 */
-	if (strends(prop->name, ",nr-gpios"))
+	if (strstr(prop->name, "nr-gpio"))
 		return false;
 
-	return strends(prop->name, "-gpios") ||
-		streq(prop->name, "gpios") ||
-		strends(prop->name, "-gpio") ||
-		streq(prop->name, "gpio");
+	str = strrchr(prop->name, '-');
+	if (str)
+		str++;
+	else
+		str = prop->name;
+	if (!(streq(str, "gpios") || streq(str, "gpio")))
+		return false;
+
+	return true;
 }
 
 static void check_gpios_property(struct check *c,
@@ -1540,10 +1525,13 @@
 	struct property *prop;
 
 	for_each_property(node, prop) {
+		char *str;
+
 		if (!prop_is_gpio(prop))
 			continue;
 
-		if (!strends(prop->name, "gpio"))
+		str = strstr(prop->name, "gpio");
+		if (!streq(str, "gpio"))
 			continue;
 
 		FAIL_PROP(c, dti, node, prop,
@@ -1573,106 +1561,21 @@
 				     struct node *node)
 {
 	struct property *prop;
-	bool irq_provider = node_is_interrupt_provider(node);
 
-	prop = get_property(node, "#interrupt-cells");
-	if (irq_provider && !prop) {
-		FAIL(c, dti, node,
-		     "Missing '#interrupt-cells' in interrupt provider");
+	if (!node_is_interrupt_provider(node))
 		return;
-	}
 
-	if (!irq_provider && prop) {
+	prop = get_property(node, "#interrupt-cells");
+	if (!prop)
 		FAIL(c, dti, node,
-		     "'#interrupt-cells' found, but node is not an interrupt provider");
-		return;
-	}
-}
-WARNING(interrupt_provider, check_interrupt_provider, NULL, &interrupts_extended_is_cell);
+		     "Missing #interrupt-cells in interrupt provider");
 
-static void check_interrupt_map(struct check *c,
-				struct dt_info *dti,
-				struct node *node)
-{
-	struct node *root = dti->dt;
-	struct property *prop, *irq_map_prop;
-	size_t cellsize, cell, map_cells;
-
-	irq_map_prop = get_property(node, "interrupt-map");
-	if (!irq_map_prop)
-		return;
-
-	if (node->addr_cells < 0) {
+	prop = get_property(node, "#address-cells");
+	if (!prop)
 		FAIL(c, dti, node,
-		     "Missing '#address-cells' in interrupt-map provider");
-		return;
-	}
-	cellsize = node_addr_cells(node);
-	cellsize += propval_cell(get_property(node, "#interrupt-cells"));
-
-	prop = get_property(node, "interrupt-map-mask");
-	if (prop && (prop->val.len != (cellsize * sizeof(cell_t))))
-		FAIL_PROP(c, dti, node, prop,
-			  "property size (%d) is invalid, expected %zu",
-			  prop->val.len, cellsize * sizeof(cell_t));
-
-	if (!is_multiple_of(irq_map_prop->val.len, sizeof(cell_t))) {
-		FAIL_PROP(c, dti, node, irq_map_prop,
-			  "property size (%d) is invalid, expected multiple of %zu",
-			  irq_map_prop->val.len, sizeof(cell_t));
-		return;
-	}
-
-	map_cells = irq_map_prop->val.len / sizeof(cell_t);
-	for (cell = 0; cell < map_cells; ) {
-		struct node *provider_node;
-		struct property *cellprop;
-		int phandle;
-		size_t parent_cellsize;
-
-		if ((cell + cellsize) >= map_cells) {
-			FAIL_PROP(c, dti, node, irq_map_prop,
-				  "property size (%d) too small, expected > %zu",
-				  irq_map_prop->val.len, (cell + cellsize) * sizeof(cell_t));
-			break;
-		}
-		cell += cellsize;
-
-		phandle = propval_cell_n(irq_map_prop, cell);
-		if (!phandle_is_valid(phandle)) {
-			/* Give up if this is an overlay with external references */
-			if (!(dti->dtsflags & DTSF_PLUGIN))
-				FAIL_PROP(c, dti, node, irq_map_prop,
-					  "Cell %zu is not a phandle(%d)",
-					  cell, phandle);
-			break;
-		}
-
-		provider_node = get_node_by_phandle(root, phandle);
-		if (!provider_node) {
-			FAIL_PROP(c, dti, node, irq_map_prop,
-				  "Could not get phandle(%d) node for (cell %zu)",
-				  phandle, cell);
-			break;
-		}
-
-		cellprop = get_property(provider_node, "#interrupt-cells");
-		if (cellprop) {
-			parent_cellsize = propval_cell(cellprop);
-		} else {
-			FAIL(c, dti, node, "Missing property '#interrupt-cells' in node %s or bad phandle (referred from interrupt-map[%zu])",
-			     provider_node->fullpath, cell);
-			break;
-		}
-
-		cellprop = get_property(provider_node, "#address-cells");
-		if (cellprop)
-			parent_cellsize += propval_cell(cellprop);
-
-		cell += 1 + parent_cellsize;
-	}
+		     "Missing #address-cells in interrupt provider");
 }
-WARNING(interrupt_map, check_interrupt_map, NULL, &phandle_references, &addr_size_cells, &interrupt_provider);
+WARNING(interrupt_provider, check_interrupt_provider, NULL);
 
 static void check_interrupts_property(struct check *c,
 				      struct dt_info *dti,
@@ -1681,13 +1584,13 @@
 	struct node *root = dti->dt;
 	struct node *irq_node = NULL, *parent = node;
 	struct property *irq_prop, *prop = NULL;
-	cell_t irq_cells, phandle;
+	int irq_cells, phandle;
 
 	irq_prop = get_property(node, "interrupts");
 	if (!irq_prop)
 		return;
 
-	if (!is_multiple_of(irq_prop->val.len, sizeof(cell_t)))
+	if (irq_prop->val.len % sizeof(cell_t))
 		FAIL_PROP(c, dti, node, irq_prop, "size (%d) is invalid, expected multiple of %zu",
 		     irq_prop->val.len, sizeof(cell_t));
 
@@ -1700,7 +1603,7 @@
 		prop = get_property(parent, "interrupt-parent");
 		if (prop) {
 			phandle = propval_cell(prop);
-			if (!phandle_is_valid(phandle)) {
+			if ((phandle == 0) || (phandle == -1)) {
 				/* Give up if this is an overlay with
 				 * external references */
 				if (dti->dtsflags & DTSF_PLUGIN)
@@ -1736,7 +1639,7 @@
 	}
 
 	irq_cells = propval_cell(prop);
-	if (!is_multiple_of(irq_prop->val.len, irq_cells * sizeof(cell_t))) {
+	if (irq_prop->val.len % (irq_cells * sizeof(cell_t))) {
 		FAIL_PROP(c, dti, node, prop,
 			  "size is (%d), expected multiple of %d",
 			  irq_prop->val.len, (int)(irq_cells * sizeof(cell_t)));
@@ -1847,7 +1750,7 @@
 static struct node *get_remote_endpoint(struct check *c, struct dt_info *dti,
 					struct node *endpoint)
 {
-	cell_t phandle;
+	int phandle;
 	struct node *node;
 	struct property *prop;
 
@@ -1857,7 +1760,7 @@
 
 	phandle = propval_cell(prop);
 	/* Give up if this is an overlay with external references */
-	if (!phandle_is_valid(phandle))
+	if (phandle == 0 || phandle == -1)
 		return NULL;
 
 	node = get_node_by_phandle(dti->dt, phandle);
@@ -1893,7 +1796,7 @@
 static struct check *check_table[] = {
 	&duplicate_node_names, &duplicate_property_names,
 	&node_name_chars, &node_name_format, &property_name_chars,
-	&name_is_string, &name_properties, &node_name_vs_property_name,
+	&name_is_string, &name_properties,
 
 	&duplicate_label,
 
@@ -1901,7 +1804,7 @@
 	&phandle_references, &path_references,
 	&omit_unused_nodes,
 
-	&address_cells_is_cell, &size_cells_is_cell,
+	&address_cells_is_cell, &size_cells_is_cell, &interrupt_cells_is_cell,
 	&device_type_is_string, &model_is_string, &status_is_string,
 	&label_is_string,
 
@@ -1936,43 +1839,26 @@
 	&chosen_node_is_root, &chosen_node_bootargs, &chosen_node_stdout_path,
 
 	&clocks_property,
-	&clocks_is_cell,
 	&cooling_device_property,
-	&cooling_device_is_cell,
 	&dmas_property,
-	&dmas_is_cell,
 	&hwlocks_property,
-	&hwlocks_is_cell,
 	&interrupts_extended_property,
-	&interrupts_extended_is_cell,
 	&io_channels_property,
-	&io_channels_is_cell,
 	&iommus_property,
-	&iommus_is_cell,
 	&mboxes_property,
-	&mboxes_is_cell,
 	&msi_parent_property,
-	&msi_parent_is_cell,
 	&mux_controls_property,
-	&mux_controls_is_cell,
 	&phys_property,
-	&phys_is_cell,
 	&power_domains_property,
-	&power_domains_is_cell,
 	&pwms_property,
-	&pwms_is_cell,
 	&resets_property,
-	&resets_is_cell,
 	&sound_dai_property,
-	&sound_dai_is_cell,
 	&thermal_sensors_property,
-	&thermal_sensors_is_cell,
 
 	&deprecated_gpio_property,
 	&gpios_property,
 	&interrupts_property,
 	&interrupt_provider,
-	&interrupt_map,
 
 	&alias_paths,
 
@@ -1996,7 +1882,7 @@
 
 static void disable_warning_error(struct check *c, bool warn, bool error)
 {
-	unsigned int i;
+	int i;
 
 	/* Lowering level, also lower it for things this is the prereq
 	 * for */
@@ -2017,7 +1903,7 @@
 
 void parse_checks_option(bool warn, bool error, const char *arg)
 {
-	unsigned int i;
+	int i;
 	const char *name = arg;
 	bool enable = true;
 
@@ -2044,7 +1930,7 @@
 
 void process_checks(bool force, struct dt_info *dti)
 {
-	unsigned int i;
+	int i;
 	int error = 0;
 
 	for (i = 0; i < ARRAY_SIZE(check_table); i++) {
diff -urN --no-dereference a/scripts/dtc/data.c b/scripts/dtc/data.c
--- a/scripts/dtc/data.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/data.c	2023-05-02 09:43:07.658392421 +0200
@@ -21,10 +21,10 @@
 		free(d.val);
 }
 
-struct data data_grow_for(struct data d, unsigned int xlen)
+struct data data_grow_for(struct data d, int xlen)
 {
 	struct data nd;
-	unsigned int newsize;
+	int newsize;
 
 	if (xlen == 0)
 		return d;
@@ -84,7 +84,7 @@
 	while (!feof(f) && (d.len < maxlen)) {
 		size_t chunksize, ret;
 
-		if (maxlen == (size_t)-1)
+		if (maxlen == -1)
 			chunksize = 4096;
 		else
 			chunksize = maxlen - d.len;
diff -urN --no-dereference a/scripts/dtc/dtc.c b/scripts/dtc/dtc.c
--- a/scripts/dtc/dtc.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/dtc.c	2023-05-02 09:43:07.658392421 +0200
@@ -12,7 +12,7 @@
  * Command line options
  */
 int quiet;		/* Level of quietness */
-unsigned int reservenum;/* Number of memory reservation slots */
+int reservenum;		/* Number of memory reservation slots */
 int minsize;		/* Minimum blob size */
 int padsize;		/* Additional padding to blob */
 int alignsize;		/* Additional padding to blob accroding to the alignsize */
@@ -122,8 +122,6 @@
 		return "dts";
 	if (!strcasecmp(s, ".yaml"))
 		return "yaml";
-	if (!strcasecmp(s, ".dtbo"))
-		return "dtb";
 	if (!strcasecmp(s, ".dtb"))
 		return "dtb";
 	return fallback;
@@ -197,7 +195,7 @@
 			depname = optarg;
 			break;
 		case 'R':
-			reservenum = strtoul(optarg, NULL, 0);
+			reservenum = strtol(optarg, NULL, 0);
 			break;
 		case 'S':
 			minsize = strtol(optarg, NULL, 0);
diff -urN --no-dereference a/scripts/dtc/dtc.h b/scripts/dtc/dtc.h
--- a/scripts/dtc/dtc.h	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/dtc.h	2023-05-02 09:43:07.658392421 +0200
@@ -35,7 +35,7 @@
  * Command line options
  */
 extern int quiet;		/* Level of quietness */
-extern unsigned int reservenum;	/* Number of memory reservation slots */
+extern int reservenum;		/* Number of memory reservation slots */
 extern int minsize;		/* Minimum blob size */
 extern int padsize;		/* Additional padding to blob */
 extern int alignsize;		/* Additional padding to blob accroding to the alignsize */
@@ -51,11 +51,6 @@
 
 typedef uint32_t cell_t;
 
-static inline bool phandle_is_valid(cell_t phandle)
-{
-	return phandle != 0 && phandle != ~0U;
-}
-
 static inline uint16_t dtb_ld16(const void *p)
 {
 	const uint8_t *bp = (const uint8_t *)p;
@@ -91,16 +86,6 @@
 #define streq(a, b)	(strcmp((a), (b)) == 0)
 #define strstarts(s, prefix)	(strncmp((s), (prefix), strlen(prefix)) == 0)
 #define strprefixeq(a, n, b)	(strlen(b) == (n) && (memcmp(a, b, n) == 0))
-static inline bool strends(const char *str, const char *suffix)
-{
-	unsigned int len, suffix_len;
-
-	len = strlen(str);
-	suffix_len = strlen(suffix);
-	if (len < suffix_len)
-		return false;
-	return streq(str + len - suffix_len, suffix);
-}
 
 #define ALIGN(x, a)	(((x) + (a) - 1) & ~((a) - 1))
 
@@ -116,23 +101,17 @@
 	TYPE_UINT64,
 	TYPE_STRING,
 };
-
-static inline bool is_type_marker(enum markertype type)
-{
-	return type >= TYPE_UINT8;
-}
-
 extern const char *markername(enum markertype markertype);
 
 struct  marker {
 	enum markertype type;
-	unsigned int offset;
+	int offset;
 	char *ref;
 	struct marker *next;
 };
 
 struct data {
-	unsigned int len;
+	int len;
 	char *val;
 	struct marker *markers;
 };
@@ -146,26 +125,11 @@
 	for_each_marker(m) \
 		if ((m)->type == (t))
 
-static inline struct marker *next_type_marker(struct marker *m)
-{
-	for_each_marker(m)
-		if (is_type_marker(m->type))
-			break;
-	return m;
-}
-
-static inline size_t type_marker_length(struct marker *m)
-{
-	struct marker *next = next_type_marker(m->next);
-
-	if (next)
-		return next->offset - m->offset;
-	return 0;
-}
+size_t type_marker_length(struct marker *m);
 
 void data_free(struct data d);
 
-struct data data_grow_for(struct data d, unsigned int xlen);
+struct data data_grow_for(struct data d, int xlen);
 
 struct data data_copy_mem(const char *mem, int len);
 struct data data_copy_escape_string(const char *s, int len);
@@ -289,7 +253,7 @@
 const char *get_unitname(struct node *node);
 struct property *get_property(struct node *node, const char *propname);
 cell_t propval_cell(struct property *prop);
-cell_t propval_cell_n(struct property *prop, unsigned int n);
+cell_t propval_cell_n(struct property *prop, int n);
 struct property *get_property_by_label(struct node *tree, const char *label,
 				       struct node **node);
 struct marker *get_marker_label(struct node *tree, const char *label,
diff -urN --no-dereference a/scripts/dtc/dtc-lexer.l b/scripts/dtc/dtc-lexer.l
--- a/scripts/dtc/dtc-lexer.l	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/dtc-lexer.l	2023-05-02 09:42:59.268414764 +0200
@@ -57,7 +57,7 @@
 			push_input_file(name);
 		}
 
-<*>^"#"(line)?[ \t]+[0-9]+[ \t]+{STRING}([ \t]+[0-9]+)* {
+<*>^"#"(line)?[ \t]+[0-9]+[ \t]+{STRING}([ \t]+[0-9]+)? {
 			char *line, *fnstart, *fnend;
 			struct data fn;
 			/* skip text before line # */
diff -urN --no-dereference a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
--- a/scripts/dtc/flattree.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/flattree.c	2023-05-02 09:43:07.658392421 +0200
@@ -124,8 +124,7 @@
 {
 	FILE *f = e;
 
-	fprintf(f, "\t.byte\t0x%02x\n" "\t.byte\t0x%02x\n"
-		"\t.byte\t0x%02x\n" "\t.byte\t0x%02x\n",
+	fprintf(f, "\t.byte 0x%02x; .byte 0x%02x; .byte 0x%02x; .byte 0x%02x\n",
 		(val >> 24) & 0xff, (val >> 16) & 0xff,
 		(val >> 8) & 0xff, val & 0xff);
 }
@@ -135,9 +134,9 @@
 	FILE *f = e;
 
 	if (len != 0)
-		fprintf(f, "\t.asciz\t\"%.*s\"\n", len, str);
+		fprintf(f, "\t.string\t\"%.*s\"\n", len, str);
 	else
-		fprintf(f, "\t.asciz\t\"%s\"\n", str);
+		fprintf(f, "\t.string\t\"%s\"\n", str);
 }
 
 static void asm_emit_align(void *e, int a)
@@ -150,7 +149,7 @@
 static void asm_emit_data(void *e, struct data d)
 {
 	FILE *f = e;
-	unsigned int off = 0;
+	int off = 0;
 	struct marker *m = d.markers;
 
 	for_each_marker_of_type(m, LABEL)
@@ -220,7 +219,7 @@
 
 static int stringtable_insert(struct data *d, const char *str)
 {
-	unsigned int i;
+	int i;
 
 	/* FIXME: do this more efficiently? */
 
@@ -296,7 +295,7 @@
 {
 	struct reserve_info *re;
 	struct data d = empty_data;
-	unsigned int j;
+	int    j;
 
 	for (re = reservelist; re; re = re->next) {
 		d = data_append_re(d, re->address, re->size);
@@ -346,7 +345,7 @@
 void dt_to_blob(FILE *f, struct dt_info *dti, int version)
 {
 	struct version_info *vi = NULL;
-	unsigned int i;
+	int i;
 	struct data blob       = empty_data;
 	struct data reservebuf = empty_data;
 	struct data dtbuf      = empty_data;
@@ -439,7 +438,7 @@
 
 	while (p < (strbuf.val + strbuf.len)) {
 		len = strlen(p);
-		fprintf(f, "\t.asciz \"%s\"\n", p);
+		fprintf(f, "\t.string \"%s\"\n", p);
 		p += len+1;
 	}
 }
@@ -447,7 +446,7 @@
 void dt_to_asm(FILE *f, struct dt_info *dti, int version)
 {
 	struct version_info *vi = NULL;
-	unsigned int i;
+	int i;
 	struct data strbuf = empty_data;
 	struct reserve_info *re;
 	const char *symprefix = "dt";
diff -urN --no-dereference a/scripts/dtc/libfdt/fdt.c b/scripts/dtc/libfdt/fdt.c
--- a/scripts/dtc/libfdt/fdt.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/libfdt/fdt.c	2023-05-02 09:43:07.658392421 +0200
@@ -22,10 +22,6 @@
 	if (can_assume(VALID_DTB))
 		return totalsize;
 
-	/* The device tree must be at an 8-byte aligned address */
-	if ((uintptr_t)fdt & 7)
-		return -FDT_ERR_ALIGNMENT;
-
 	if (fdt_magic(fdt) == FDT_MAGIC) {
 		/* Complete tree */
 		if (!can_assume(LATEST)) {
@@ -90,10 +86,6 @@
 {
 	size_t hdrsize;
 
-	/* The device tree must be at an 8-byte aligned address */
-	if ((uintptr_t)fdt & 7)
-		return -FDT_ERR_ALIGNMENT;
-
 	if (fdt_magic(fdt) != FDT_MAGIC)
 		return -FDT_ERR_BADMAGIC;
 	if (!can_assume(LATEST)) {
diff -urN --no-dereference a/scripts/dtc/libfdt/fdt_ro.c b/scripts/dtc/libfdt/fdt_ro.c
--- a/scripts/dtc/libfdt/fdt_ro.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/libfdt/fdt_ro.c	2023-05-02 09:43:07.661725745 +0200
@@ -181,8 +181,8 @@
 	if (!can_assume(VALID_INPUT) && !re)
 		return -FDT_ERR_BADOFFSET;
 
-	*address = fdt64_ld_(&re->address);
-	*size = fdt64_ld_(&re->size);
+	*address = fdt64_ld(&re->address);
+	*size = fdt64_ld(&re->size);
 	return 0;
 }
 
@@ -192,7 +192,7 @@
 	const struct fdt_reserve_entry *re;
 
 	for (i = 0; (re = fdt_mem_rsv(fdt, i)) != NULL; i++) {
-		if (fdt64_ld_(&re->size) == 0)
+		if (fdt64_ld(&re->size) == 0)
 			return i;
 	}
 	return -FDT_ERR_TRUNCATED;
@@ -370,7 +370,7 @@
 	prop = fdt_offset_ptr_(fdt, offset);
 
 	if (lenp)
-		*lenp = fdt32_ld_(&prop->len);
+		*lenp = fdt32_ld(&prop->len);
 
 	return prop;
 }
@@ -408,7 +408,7 @@
 			offset = -FDT_ERR_INTERNAL;
 			break;
 		}
-		if (fdt_string_eq_(fdt, fdt32_ld_(&prop->nameoff),
+		if (fdt_string_eq_(fdt, fdt32_ld(&prop->nameoff),
 				   name, namelen)) {
 			if (poffset)
 				*poffset = offset;
@@ -461,7 +461,7 @@
 
 	/* Handle realignment */
 	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10 &&
-	    (poffset + sizeof(*prop)) % 8 && fdt32_ld_(&prop->len) >= 8)
+	    (poffset + sizeof(*prop)) % 8 && fdt32_ld(&prop->len) >= 8)
 		return prop->data + 4;
 	return prop->data;
 }
@@ -479,7 +479,7 @@
 		int namelen;
 
 		if (!can_assume(VALID_INPUT)) {
-			name = fdt_get_string(fdt, fdt32_ld_(&prop->nameoff),
+			name = fdt_get_string(fdt, fdt32_ld(&prop->nameoff),
 					      &namelen);
 			if (!name) {
 				if (lenp)
@@ -488,13 +488,13 @@
 			}
 			*namep = name;
 		} else {
-			*namep = fdt_string(fdt, fdt32_ld_(&prop->nameoff));
+			*namep = fdt_string(fdt, fdt32_ld(&prop->nameoff));
 		}
 	}
 
 	/* Handle realignment */
 	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10 &&
-	    (offset + sizeof(*prop)) % 8 && fdt32_ld_(&prop->len) >= 8)
+	    (offset + sizeof(*prop)) % 8 && fdt32_ld(&prop->len) >= 8)
 		return prop->data + 4;
 	return prop->data;
 }
@@ -519,7 +519,7 @@
 			return 0;
 	}
 
-	return fdt32_ld_(php);
+	return fdt32_ld(php);
 }
 
 const char *fdt_get_alias_namelen(const void *fdt,
diff -urN --no-dereference a/scripts/dtc/libfdt/fdt_rw.c b/scripts/dtc/libfdt/fdt_rw.c
--- a/scripts/dtc/libfdt/fdt_rw.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/libfdt/fdt_rw.c	2023-05-02 09:43:07.661725745 +0200
@@ -349,10 +349,7 @@
 		return offset;
 
 	/* Try to place the new node after the parent's properties */
-	tag = fdt_next_tag(fdt, parentoffset, &nextoffset);
-	/* the fdt_subnode_offset_namelen() should ensure this never hits */
-	if (!can_assume(LIBFDT_FLAWLESS) && (tag != FDT_BEGIN_NODE))
-		return -FDT_ERR_INTERNAL;
+	fdt_next_tag(fdt, parentoffset, &nextoffset); /* skip the BEGIN_NODE */
 	do {
 		offset = nextoffset;
 		tag = fdt_next_tag(fdt, offset, &nextoffset);
@@ -394,9 +391,7 @@
 }
 
 static void fdt_packblocks_(const char *old, char *new,
-			    int mem_rsv_size,
-			    int struct_size,
-			    int strings_size)
+			    int mem_rsv_size, int struct_size)
 {
 	int mem_rsv_off, struct_off, strings_off;
 
@@ -411,7 +406,8 @@
 	fdt_set_off_dt_struct(new, struct_off);
 	fdt_set_size_dt_struct(new, struct_size);
 
-	memmove(new + strings_off, old + fdt_off_dt_strings(old), strings_size);
+	memmove(new + strings_off, old + fdt_off_dt_strings(old),
+		fdt_size_dt_strings(old));
 	fdt_set_off_dt_strings(new, strings_off);
 	fdt_set_size_dt_strings(new, fdt_size_dt_strings(old));
 }
@@ -432,14 +428,12 @@
 
 	if (can_assume(LATEST) || fdt_version(fdt) >= 17) {
 		struct_size = fdt_size_dt_struct(fdt);
-	} else if (fdt_version(fdt) == 16) {
+	} else {
 		struct_size = 0;
 		while (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)
 			;
 		if (struct_size < 0)
 			return struct_size;
-	} else {
-		return -FDT_ERR_BADVERSION;
 	}
 
 	if (can_assume(LIBFDT_ORDER) ||
@@ -471,8 +465,7 @@
 			return -FDT_ERR_NOSPACE;
 	}
 
-	fdt_packblocks_(fdt, tmp, mem_rsv_size, struct_size,
-			fdt_size_dt_strings(fdt));
+	fdt_packblocks_(fdt, tmp, mem_rsv_size, struct_size);
 	memmove(buf, tmp, newsize);
 
 	fdt_set_magic(buf, FDT_MAGIC);
@@ -492,8 +485,7 @@
 
 	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
 		* sizeof(struct fdt_reserve_entry);
-	fdt_packblocks_(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt),
-			fdt_size_dt_strings(fdt));
+	fdt_packblocks_(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt));
 	fdt_set_totalsize(fdt, fdt_data_size_(fdt));
 
 	return 0;
diff -urN --no-dereference a/scripts/dtc/libfdt/fdt_strerror.c b/scripts/dtc/libfdt/fdt_strerror.c
--- a/scripts/dtc/libfdt/fdt_strerror.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/libfdt/fdt_strerror.c	2023-05-02 09:42:59.268414764 +0200
@@ -39,7 +39,6 @@
 	FDT_ERRTABENT(FDT_ERR_BADOVERLAY),
 	FDT_ERRTABENT(FDT_ERR_NOPHANDLES),
 	FDT_ERRTABENT(FDT_ERR_BADFLAGS),
-	FDT_ERRTABENT(FDT_ERR_ALIGNMENT),
 };
 #define FDT_ERRTABSIZE	((int)(sizeof(fdt_errtable) / sizeof(fdt_errtable[0])))
 
diff -urN --no-dereference a/scripts/dtc/libfdt/fdt_sw.c b/scripts/dtc/libfdt/fdt_sw.c
--- a/scripts/dtc/libfdt/fdt_sw.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/libfdt/fdt_sw.c	2023-05-02 09:43:07.661725745 +0200
@@ -377,7 +377,7 @@
 	fdt_set_totalsize(fdt, newstroffset + fdt_size_dt_strings(fdt));
 
 	/* And fix up fields that were keeping intermediate state. */
-	fdt_set_last_comp_version(fdt, FDT_LAST_COMPATIBLE_VERSION);
+	fdt_set_last_comp_version(fdt, FDT_FIRST_SUPPORTED_VERSION);
 	fdt_set_magic(fdt, FDT_MAGIC);
 
 	return 0;
diff -urN --no-dereference a/scripts/dtc/libfdt/libfdt.h b/scripts/dtc/libfdt/libfdt.h
--- a/scripts/dtc/libfdt/libfdt.h	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/libfdt/libfdt.h	2023-05-02 09:43:07.661725745 +0200
@@ -14,7 +14,6 @@
 #endif
 
 #define FDT_FIRST_SUPPORTED_VERSION	0x02
-#define FDT_LAST_COMPATIBLE_VERSION 0x10
 #define FDT_LAST_SUPPORTED_VERSION	0x11
 
 /* Error codes: informative error codes */
@@ -102,11 +101,7 @@
 	/* FDT_ERR_BADFLAGS: The function was passed a flags field that
 	 * contains invalid flags or an invalid combination of flags. */
 
-#define FDT_ERR_ALIGNMENT	19
-	/* FDT_ERR_ALIGNMENT: The device tree base address is not 8-byte
-	 * aligned. */
-
-#define FDT_ERR_MAX		19
+#define FDT_ERR_MAX		18
 
 /* constants */
 #define FDT_MAX_PHANDLE 0xfffffffe
@@ -127,16 +122,11 @@
 uint32_t fdt_next_tag(const void *fdt, int offset, int *nextoffset);
 
 /*
- * External helpers to access words from a device tree blob. They're built
- * to work even with unaligned pointers on platforms (such as ARMv5) that don't
- * like unaligned loads and stores.
+ * Alignment helpers:
+ *     These helpers access words from a device tree blob.  They're
+ *     built to work even with unaligned pointers on platforms (ike
+ *     ARM) that don't like unaligned loads and stores
  */
-static inline uint16_t fdt16_ld(const fdt16_t *p)
-{
-	const uint8_t *bp = (const uint8_t *)p;
-
-	return ((uint16_t)bp[0] << 8) | bp[1];
-}
 
 static inline uint32_t fdt32_ld(const fdt32_t *p)
 {
@@ -194,23 +184,23 @@
 
 /**
  * fdt_first_subnode() - get offset of first direct subnode
+ *
  * @fdt:	FDT blob
  * @offset:	Offset of node to check
- *
- * Return: offset of first subnode, or -FDT_ERR_NOTFOUND if there is none
+ * @return offset of first subnode, or -FDT_ERR_NOTFOUND if there is none
  */
 int fdt_first_subnode(const void *fdt, int offset);
 
 /**
  * fdt_next_subnode() - get offset of next direct subnode
- * @fdt:	FDT blob
- * @offset:	Offset of previous subnode
  *
  * After first calling fdt_first_subnode(), call this function repeatedly to
  * get direct subnodes of a parent node.
  *
- * Return: offset of next subnode, or -FDT_ERR_NOTFOUND if there are no more
- *         subnodes
+ * @fdt:	FDT blob
+ * @offset:	Offset of previous subnode
+ * @return offset of next subnode, or -FDT_ERR_NOTFOUND if there are no more
+ * subnodes
  */
 int fdt_next_subnode(const void *fdt, int offset);
 
@@ -235,6 +225,7 @@
  * Note that this is implemented as a macro and @node is used as
  * iterator in the loop. The parent variable be constant or even a
  * literal.
+ *
  */
 #define fdt_for_each_subnode(node, fdt, parent)		\
 	for (node = fdt_first_subnode(fdt, parent);	\
@@ -278,21 +269,17 @@
 /**
  * fdt_header_size - return the size of the tree's header
  * @fdt: pointer to a flattened device tree
- *
- * Return: size of DTB header in bytes
  */
 size_t fdt_header_size(const void *fdt);
 
 /**
- * fdt_header_size_ - internal function to get header size from a version number
- * @version: devicetree version number
- *
- * Return: size of DTB header in bytes
+ * fdt_header_size_ - internal function which takes a version number
  */
 size_t fdt_header_size_(uint32_t version);
 
 /**
  * fdt_check_header - sanity check a device tree header
+
  * @fdt: pointer to data which might be a flattened device tree
  *
  * fdt_check_header() checks that the given buffer contains what
@@ -417,7 +404,8 @@
  * highest phandle value in the device tree blob) will be returned in the
  * @phandle parameter.
  *
- * Return: 0 on success or a negative error-code on failure
+ * Returns:
+ *   0 on success or a negative error-code on failure
  */
 int fdt_generate_phandle(const void *fdt, uint32_t *phandle);
 
@@ -437,11 +425,9 @@
 /**
  * fdt_get_mem_rsv - retrieve one memory reserve map entry
  * @fdt: pointer to the device tree blob
- * @n: index of reserve map entry
- * @address: pointer to 64-bit variable to hold the start address
- * @size: pointer to 64-bit variable to hold the size of the entry
+ * @address, @size: pointers to 64-bit variables
  *
- * On success, @address and @size will contain the address and size of
+ * On success, *address and *size will contain the address and size of
  * the n-th reserve map entry from the device tree blob, in
  * native-endian format.
  *
@@ -464,8 +450,6 @@
  * namelen characters of name for matching the subnode name.  This is
  * useful for finding subnodes based on a portion of a larger string,
  * such as a full path.
- *
- * Return: offset of the subnode or -FDT_ERR_NOTFOUND if name not found.
  */
 #ifndef SWIG /* Not available in Python */
 int fdt_subnode_offset_namelen(const void *fdt, int parentoffset,
@@ -505,8 +489,6 @@
  *
  * Identical to fdt_path_offset(), but only consider the first namelen
  * characters of path as the path name.
- *
- * Return: offset of the node or negative libfdt error value otherwise
  */
 #ifndef SWIG /* Not available in Python */
 int fdt_path_offset_namelen(const void *fdt, const char *path, int namelen);
@@ -606,9 +588,9 @@
 /**
  * fdt_for_each_property_offset - iterate over all properties of a node
  *
- * @property:	property offset (int, lvalue)
- * @fdt:	FDT blob (const void *)
- * @node:	node offset (int)
+ * @property_offset:	property offset (int, lvalue)
+ * @fdt:		FDT blob (const void *)
+ * @node:		node offset (int)
  *
  * This is actually a wrapper around a for loop and would be used like so:
  *
@@ -671,9 +653,6 @@
  *
  * Identical to fdt_get_property(), but only examine the first namelen
  * characters of name for matching the property name.
- *
- * Return: pointer to the structure representing the property, or NULL
- *         if not found
  */
 #ifndef SWIG /* Not available in Python */
 const struct fdt_property *fdt_get_property_namelen(const void *fdt,
@@ -766,8 +745,6 @@
  *
  * Identical to fdt_getprop(), but only examine the first namelen
  * characters of name for matching the property name.
- *
- * Return: pointer to the property's value or NULL on error
  */
 #ifndef SWIG /* Not available in Python */
 const void *fdt_getprop_namelen(const void *fdt, int nodeoffset,
@@ -789,10 +766,10 @@
  * @lenp: pointer to an integer variable (will be overwritten) or NULL
  *
  * fdt_getprop() retrieves a pointer to the value of the property
- * named @name of the node at offset @nodeoffset (this will be a
+ * named 'name' of the node at offset nodeoffset (this will be a
  * pointer to within the device blob itself, not a copy of the value).
- * If @lenp is non-NULL, the length of the property value is also
- * returned, in the integer pointed to by @lenp.
+ * If lenp is non-NULL, the length of the property value is also
+ * returned, in the integer pointed to by lenp.
  *
  * returns:
  *	pointer to the property's value
@@ -837,11 +814,8 @@
  * @name: name of the alias th look up
  * @namelen: number of characters of name to consider
  *
- * Identical to fdt_get_alias(), but only examine the first @namelen
- * characters of @name for matching the alias name.
- *
- * Return: a pointer to the expansion of the alias named @name, if it exists,
- *	   NULL otherwise
+ * Identical to fdt_get_alias(), but only examine the first namelen
+ * characters of name for matching the alias name.
  */
 #ifndef SWIG /* Not available in Python */
 const char *fdt_get_alias_namelen(const void *fdt,
@@ -854,7 +828,7 @@
  * @name: name of the alias th look up
  *
  * fdt_get_alias() retrieves the value of a given alias.  That is, the
- * value of the property named @name in the node /aliases.
+ * value of the property named 'name' in the node /aliases.
  *
  * returns:
  *	a pointer to the expansion of the alias named 'name', if it exists
@@ -1030,13 +1004,14 @@
 int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle);
 
 /**
- * fdt_node_check_compatible - check a node's compatible property
+ * fdt_node_check_compatible: check a node's compatible property
  * @fdt: pointer to the device tree blob
  * @nodeoffset: offset of a tree node
  * @compatible: string to match against
  *
+ *
  * fdt_node_check_compatible() returns 0 if the given node contains a
- * @compatible property with the given string as one of its elements,
+ * 'compatible' property with the given string as one of its elements,
  * it returns non-zero otherwise, or on error.
  *
  * returns:
@@ -1100,7 +1075,7 @@
  * one or more strings, each terminated by \0, as is found in a device tree
  * "compatible" property.
  *
- * Return: 1 if the string is found in the list, 0 not found, or invalid list
+ * @return: 1 if the string is found in the list, 0 not found, or invalid list
  */
 int fdt_stringlist_contains(const char *strlist, int listlen, const char *str);
 
@@ -1109,8 +1084,7 @@
  * @fdt: pointer to the device tree blob
  * @nodeoffset: offset of a tree node
  * @property: name of the property containing the string list
- *
- * Return:
+ * @return:
  *   the number of strings in the given property
  *   -FDT_ERR_BADVALUE if the property value is not NUL-terminated
  *   -FDT_ERR_NOTFOUND if the property does not exist
@@ -1130,7 +1104,7 @@
  * small-valued cell properties, such as #address-cells, when searching for
  * the empty string.
  *
- * return:
+ * @return:
  *   the index of the string in the list of strings
  *   -FDT_ERR_BADVALUE if the property value is not NUL-terminated
  *   -FDT_ERR_NOTFOUND if the property does not exist or does not contain
@@ -1154,7 +1128,7 @@
  * If non-NULL, the length of the string (on success) or a negative error-code
  * (on failure) will be stored in the integer pointer to by lenp.
  *
- * Return:
+ * @return:
  *   A pointer to the string at the given index in the string list or NULL on
  *   failure. On success the length of the string will be stored in the memory
  *   location pointed to by the lenp parameter, if non-NULL. On failure one of
@@ -1243,8 +1217,6 @@
  * starting from the given index, and using only the first characters
  * of the name. It is useful when you want to manipulate only one value of
  * an array and you have a string that doesn't end with \0.
- *
- * Return: 0 on success, negative libfdt error value otherwise
  */
 #ifndef SWIG /* Not available in Python */
 int fdt_setprop_inplace_namelen_partial(void *fdt, int nodeoffset,
@@ -1358,13 +1330,8 @@
 
 /**
  * fdt_setprop_inplace_cell - change the value of a single-cell property
- * @fdt: pointer to the device tree blob
- * @nodeoffset: offset of the node containing the property
- * @name: name of the property to change the value of
- * @val: new value of the 32-bit cell
  *
  * This is an alternative name for fdt_setprop_inplace_u32()
- * Return: 0 on success, negative libfdt error number otherwise.
  */
 static inline int fdt_setprop_inplace_cell(void *fdt, int nodeoffset,
 					   const char *name, uint32_t val)
@@ -1436,7 +1403,7 @@
 
 /**
  * fdt_create_with_flags - begin creation of a new fdt
- * @buf: pointer to memory allocated where fdt will be created
+ * @fdt: pointer to memory allocated where fdt will be created
  * @bufsize: size of the memory space at fdt
  * @flags: a valid combination of FDT_CREATE_FLAG_ flags, or 0.
  *
@@ -1454,7 +1421,7 @@
 
 /**
  * fdt_create - begin creation of a new fdt
- * @buf: pointer to memory allocated where fdt will be created
+ * @fdt: pointer to memory allocated where fdt will be created
  * @bufsize: size of the memory space at fdt
  *
  * fdt_create() is equivalent to fdt_create_with_flags() with flags=0.
@@ -1519,8 +1486,7 @@
 /**
  * fdt_add_mem_rsv - add one memory reserve map entry
  * @fdt: pointer to the device tree blob
- * @address: 64-bit start address of the reserve map entry
- * @size: 64-bit size of the reserved region
+ * @address, @size: 64-bit values (native endian)
  *
  * Adds a reserve map entry to the given blob reserving a region at
  * address address of length size.
@@ -1725,14 +1691,8 @@
 
 /**
  * fdt_setprop_cell - set a property to a single cell value
- * @fdt: pointer to the device tree blob
- * @nodeoffset: offset of the node whose property to change
- * @name: name of the property to change
- * @val: 32-bit integer value for the property (native endian)
  *
  * This is an alternative name for fdt_setprop_u32()
- *
- * Return: 0 on success, negative libfdt error value otherwise.
  */
 static inline int fdt_setprop_cell(void *fdt, int nodeoffset, const char *name,
 				   uint32_t val)
@@ -1903,14 +1863,8 @@
 
 /**
  * fdt_appendprop_cell - append a single cell value to a property
- * @fdt: pointer to the device tree blob
- * @nodeoffset: offset of the node whose property to change
- * @name: name of the property to change
- * @val: 32-bit integer value to append to the property (native endian)
  *
  * This is an alternative name for fdt_appendprop_u32()
- *
- * Return: 0 on success, negative libfdt error value otherwise.
  */
 static inline int fdt_appendprop_cell(void *fdt, int nodeoffset,
 				      const char *name, uint32_t val)
@@ -2013,16 +1967,13 @@
  * fdt_add_subnode_namelen - creates a new node based on substring
  * @fdt: pointer to the device tree blob
  * @parentoffset: structure block offset of a node
- * @name: name of the subnode to create
+ * @name: name of the subnode to locate
  * @namelen: number of characters of name to consider
  *
- * Identical to fdt_add_subnode(), but use only the first @namelen
- * characters of @name as the name of the new node.  This is useful for
+ * Identical to fdt_add_subnode(), but use only the first namelen
+ * characters of name as the name of the new node.  This is useful for
  * creating subnodes based on a portion of a larger string, such as a
  * full path.
- *
- * Return: structure block offset of the created subnode (>=0),
- *	   negative libfdt error value otherwise
  */
 #ifndef SWIG /* Not available in Python */
 int fdt_add_subnode_namelen(void *fdt, int parentoffset,
@@ -2041,7 +1992,7 @@
  *
  * This function will insert data into the blob, and will therefore
  * change the offsets of some existing nodes.
- *
+
  * returns:
  *	structure block offset of the created nodeequested subnode (>=0), on
  *		success
diff -urN --no-dereference a/scripts/dtc/libfdt/libfdt_internal.h b/scripts/dtc/libfdt/libfdt_internal.h
--- a/scripts/dtc/libfdt/libfdt_internal.h	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/libfdt/libfdt_internal.h	2023-05-02 09:43:07.661725745 +0200
@@ -46,25 +46,6 @@
 	return (void *)(uintptr_t)fdt_mem_rsv_(fdt, n);
 }
 
-/*
- * Internal helpers to access tructural elements of the device tree
- * blob (rather than for exaple reading integers from within property
- * values).  We assume that we are either given a naturally aligned
- * address for the platform or if we are not, we are on a platform
- * where unaligned memory reads will be handled in a graceful manner.
- * If not the external helpers fdtXX_ld() from libfdt.h can be used
- * instead.
- */
-static inline uint32_t fdt32_ld_(const fdt32_t *p)
-{
-	return fdt32_to_cpu(*p);
-}
-
-static inline uint64_t fdt64_ld_(const fdt64_t *p)
-{
-	return fdt64_to_cpu(*p);
-}
-
 #define FDT_SW_MAGIC		(~FDT_MAGIC)
 
 /**********************************************************************/
diff -urN --no-dereference a/scripts/dtc/livetree.c b/scripts/dtc/livetree.c
--- a/scripts/dtc/livetree.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/livetree.c	2023-05-02 09:43:07.661725745 +0200
@@ -438,7 +438,7 @@
 	return fdt32_to_cpu(*((fdt32_t *)prop->val.val));
 }
 
-cell_t propval_cell_n(struct property *prop, unsigned int n)
+cell_t propval_cell_n(struct property *prop, int n)
 {
 	assert(prop->val.len / sizeof(cell_t) >= n);
 	return fdt32_to_cpu(*((fdt32_t *)prop->val.val + n));
@@ -526,7 +526,7 @@
 	p = strchr(path, '/');
 
 	for_each_child(tree, child) {
-		if (p && strprefixeq(path, (size_t)(p - path), child->name))
+		if (p && strprefixeq(path, p - path, child->name))
 			return get_node_by_path(child, p+1);
 		else if (!p && streq(path, child->name))
 			return child;
@@ -559,7 +559,7 @@
 {
 	struct node *child, *node;
 
-	if (!phandle_is_valid(phandle)) {
+	if ((phandle == 0) || (phandle == -1)) {
 		assert(generate_fixups);
 		return NULL;
 	}
@@ -594,7 +594,7 @@
 	static cell_t phandle = 1; /* FIXME: ick, static local */
 	struct data d = empty_data;
 
-	if (phandle_is_valid(node->phandle))
+	if ((node->phandle != 0) && (node->phandle != -1))
 		return node->phandle;
 
 	while (get_node_by_phandle(root, phandle))
diff -urN --no-dereference a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
--- a/scripts/dtc/srcpos.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/srcpos.c	2023-05-02 09:43:07.661725745 +0200
@@ -20,7 +20,7 @@
 static struct search_path *search_path_head, **search_path_tail;
 
 /* Detect infinite include recursion. */
-#define MAX_SRCFILE_DEPTH     (200)
+#define MAX_SRCFILE_DEPTH     (100)
 static int srcfile_depth; /* = 0 */
 
 static char *get_dirname(const char *path)
diff -urN --no-dereference a/scripts/dtc/treesource.c b/scripts/dtc/treesource.c
--- a/scripts/dtc/treesource.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/treesource.c	2023-05-02 09:42:59.268414764 +0200
@@ -124,6 +124,27 @@
 	}
 }
 
+static bool has_data_type_information(struct marker *m)
+{
+	return m->type >= TYPE_UINT8;
+}
+
+static struct marker *next_type_marker(struct marker *m)
+{
+	while (m && !has_data_type_information(m))
+		m = m->next;
+	return m;
+}
+
+size_t type_marker_length(struct marker *m)
+{
+	struct marker *next = next_type_marker(m->next);
+
+	if (next)
+		return next->offset - m->offset;
+	return 0;
+}
+
 static const char *delim_start[] = {
 	[TYPE_UINT8] = "[",
 	[TYPE_UINT16] = "/bits/ 16 <",
@@ -208,39 +229,26 @@
 		size_t chunk_len = (m->next ? m->next->offset : len) - m->offset;
 		size_t data_len = type_marker_length(m) ? : len - m->offset;
 		const char *p = &prop->val.val[m->offset];
-		struct marker *m_phandle;
 
-		if (is_type_marker(m->type)) {
+		if (has_data_type_information(m)) {
 			emit_type = m->type;
 			fprintf(f, " %s", delim_start[emit_type]);
 		} else if (m->type == LABEL)
 			fprintf(f, " %s:", m->ref);
+		else if (m->offset)
+			fputc(' ', f);
 
-		if (emit_type == TYPE_NONE || chunk_len == 0)
+		if (emit_type == TYPE_NONE) {
+			assert(chunk_len == 0);
 			continue;
+		}
 
 		switch(emit_type) {
 		case TYPE_UINT16:
 			write_propval_int(f, p, chunk_len, 2);
 			break;
 		case TYPE_UINT32:
-			m_phandle = prop->val.markers;
-			for_each_marker_of_type(m_phandle, REF_PHANDLE)
-				if (m->offset == m_phandle->offset)
-					break;
-
-			if (m_phandle) {
-				if (m_phandle->ref[0] == '/')
-					fprintf(f, "&{%s}", m_phandle->ref);
-				else
-					fprintf(f, "&%s", m_phandle->ref);
-				if (chunk_len > 4) {
-					fputc(' ', f);
-					write_propval_int(f, p + 4, chunk_len - 4, 4);
-				}
-			} else {
-				write_propval_int(f, p, chunk_len, 4);
-			}
+			write_propval_int(f, p, chunk_len, 4);
 			break;
 		case TYPE_UINT64:
 			write_propval_int(f, p, chunk_len, 8);
diff -urN --no-dereference a/scripts/dtc/util.h b/scripts/dtc/util.h
--- a/scripts/dtc/util.h	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/util.h	2023-05-02 09:42:59.268414764 +0200
@@ -13,10 +13,10 @@
  */
 
 #ifdef __GNUC__
-#if __GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
-#define PRINTF(i, j)	__attribute__((format (gnu_printf, i, j)))
-#else
+#ifdef __clang__
 #define PRINTF(i, j)	__attribute__((format (printf, i, j)))
+#else
+#define PRINTF(i, j)	__attribute__((format (gnu_printf, i, j)))
 #endif
 #define NORETURN	__attribute__((noreturn))
 #else
diff -urN --no-dereference a/scripts/dtc/version_gen.h b/scripts/dtc/version_gen.h
--- a/scripts/dtc/version_gen.h	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/version_gen.h	2023-05-02 09:43:07.661725745 +0200
@@ -1 +1 @@
-#define DTC_VERSION "DTC 1.6.1-g0a3a9d34"
+#define DTC_VERSION "DTC 1.6.0-gcbca977e"
diff -urN --no-dereference a/scripts/dtc/yamltree.c b/scripts/dtc/yamltree.c
--- a/scripts/dtc/yamltree.c	2023-02-25 11:25:43.000000000 +0100
+++ b/scripts/dtc/yamltree.c	2023-05-02 09:43:07.661725745 +0200
@@ -29,12 +29,11 @@
 		    (emitter)->problem, __func__, __LINE__);		\
 })
 
-static void yaml_propval_int(yaml_emitter_t *emitter, struct marker *markers,
-	char *data, unsigned int seq_offset, unsigned int len, int width)
+static void yaml_propval_int(yaml_emitter_t *emitter, struct marker *markers, char *data, int len, int width)
 {
 	yaml_event_t event;
 	void *tag;
-	unsigned int off;
+	int off, start_offset = markers->offset;
 
 	switch(width) {
 		case 1: tag = "!u8"; break;
@@ -67,7 +66,7 @@
 			m = markers;
 			is_phandle = false;
 			for_each_marker_of_type(m, REF_PHANDLE) {
-				if (m->offset == (seq_offset + off)) {
+				if (m->offset == (start_offset + off)) {
 					is_phandle = true;
 					break;
 				}
@@ -113,9 +112,8 @@
 static void yaml_propval(yaml_emitter_t *emitter, struct property *prop)
 {
 	yaml_event_t event;
-	unsigned int len = prop->val.len;
+	int len = prop->val.len;
 	struct marker *m = prop->val.markers;
-	struct marker *markers = prop->val.markers;
 
 	/* Emit the property name */
 	yaml_scalar_event_initialize(&event, NULL,
@@ -153,19 +151,19 @@
 
 		switch(m->type) {
 		case TYPE_UINT16:
-			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 2);
+			yaml_propval_int(emitter, m, data, chunk_len, 2);
 			break;
 		case TYPE_UINT32:
-			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 4);
+			yaml_propval_int(emitter, m, data, chunk_len, 4);
 			break;
 		case TYPE_UINT64:
-			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 8);
+			yaml_propval_int(emitter, m, data, chunk_len, 8);
 			break;
 		case TYPE_STRING:
 			yaml_propval_string(emitter, data, chunk_len);
 			break;
 		default:
-			yaml_propval_int(emitter, markers, data, m->offset, chunk_len, 1);
+			yaml_propval_int(emitter, m, data, chunk_len, 1);
 			break;
 		}
 	}
